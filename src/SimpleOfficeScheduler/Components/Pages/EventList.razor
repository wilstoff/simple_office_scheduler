@page "/events"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using NodaTime
@using SimpleOfficeScheduler.Services
@inject IEventService EventService
@inject IClock Clock
@rendermode InteractiveServer

<PageTitle>Events - Office Scheduler</PageTitle>

<h3>Events</h3>

<div class="row mb-3">
    <div class="col-md-6">
        <input type="text" class="form-control" placeholder="Search events..."
               @bind="_searchTerm" @bind:event="oninput" @bind:after="OnSearchInput" />
    </div>
    <div class="col-md-6 text-end">
        <a href="events/create" class="btn btn-primary">Create Event</a>
    </div>
</div>

@if (_events is null)
{
    <div class="d-flex align-items-center gap-2 py-4">
        <span class="spinner-border spinner-border-sm text-primary"></span>
        <span class="text-muted">Loading events...</span>
    </div>
}
else if (!_events.Any())
{
    <div class="text-center py-5">
        <div class="text-muted mb-2" style="font-size: 2.5rem;">&#128197;</div>
        <p class="text-muted mb-0">@(string.IsNullOrEmpty(_searchTerm) ? "No events yet." : "No events match your search.")</p>
        @if (string.IsNullOrEmpty(_searchTerm))
        {
            <a href="events/create" class="btn btn-primary btn-sm mt-3">Create your first event</a>
        }
    </div>
}
else
{
    <div class="table-responsive">
        <table class="table table-hover">
            <thead>
                <tr>
                    <th>Title</th>
                    <th>Owner</th>
                    <th>Next Occurrence</th>
                    <th>Capacity</th>
                    <th>Recurring</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
                @foreach (var evt in _events)
                {
                    var zone = TimeZoneHelper.GetZone(evt.TimeZoneId);
                    var nowInTz = Clock.GetCurrentInstant().InZone(zone).LocalDateTime;
                    var nextOccurrence = evt.Occurrences?
                        .Where(o => !o.IsCancelled && o.StartTime.CompareTo(nowInTz) > 0)
                        .OrderBy(o => o.StartTime)
                        .FirstOrDefault();

                    <tr>
                        <td>@evt.Title</td>
                        <td>@evt.Owner.DisplayName</td>
                        <td>
                            @if (nextOccurrence is not null)
                            {
                                @nextOccurrence.StartTime.ToDateTimeUnspecified().ToString("MMM dd, yyyy h:mm tt")
                            }
                            else
                            {
                                <span class="text-muted">No upcoming</span>
                            }
                        </td>
                        <td>@evt.Capacity</td>
                        <td>
                            @if (evt.Recurrence is not null)
                            {
                                <span class="badge bg-info">@evt.Recurrence.Type</span>
                            }
                            else
                            {
                                <span class="badge bg-secondary">One-time</span>
                            }
                        </td>
                        <td>
                            <a href="events/@evt.Id" class="btn btn-sm btn-outline-primary">View</a>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code {
    private List<Event>? _events;
    private string? _searchTerm;
    private CancellationTokenSource? _debounceTimer;

    protected override async Task OnInitializedAsync()
    {
        await Search();
    }

    private async Task OnSearchInput()
    {
        // Cancel any pending debounce
        _debounceTimer?.Cancel();
        _debounceTimer = new CancellationTokenSource();
        var token = _debounceTimer.Token;

        try
        {
            await Task.Delay(250, token);
            if (!token.IsCancellationRequested)
                await Search();
        }
        catch (TaskCanceledException) { }
    }

    private async Task Search()
    {
        _events = await EventService.SearchEventsAsync(_searchTerm);
    }
}
